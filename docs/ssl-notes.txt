

Not many people realise that the unencrypted SSL handshake
(ClientHello message) reveals some details about the client.

For given application using SSL it is possible to fingerprint
underlying SSL library. In many cases, especially in the browser
world, it is even possible to pinpoint specific application and
release.

As SSL traffic is unharmed by proxies or routers, we can have high
confidentiality that the SSL fingerprint does identify a genuine
client. This may be very for detecting NAT's.

Although initial frames sent from both SSL client and server are
similar, only frame sent by the client - ClientHello, can be passively
fingerprinted. The server frame - ServerHello doesn't have enough
information. If you wish to fingerprint SSL servers - an active
fingerprinting tool would be more suitable.


Fingerprinting SSL is not a new idea, initial work was done in mid
2009 by Ivan Ristić:

 * https://www.ssllabs.com/projects/client-fingerprinting/

He was able to collect few dozen interesting signatures:

 * http://blog.ivanristic.com/2009/07/examples-of-the-information-collected-from-ssl-handshakes.html

Though, in his works he seem to have ignored the SSL extensions field,
which add valuable information to a fingerprint. Especially the
ordering of extensions has high value, similarly to the TCP options
ordering for TCP/IP stack fingerprinting.


SSL handshake (ClientHello message) contains following fields:

 * SSL handshake version - browsers usually use version 3, Ivan Ristić
   research shows that web crawlers (including wget) still use 2.
   We set a flag:
     'v2'  - if request is SSL version 2

 * Requested protocol version - most likely 3.1. Less likely values
   are 3.0 and 3.2. SSL crawlers trying invalid versions like 4.2 were
   seen in the wild. ('request_version')
   We set a flag:
     'ver' - if, for SSL version 3, the version on a 'request' block
             is different than on 'record' block. This behaviour was seen
             only in Opera.

 * gmt_unix_time - a timestamp from the client. Adding this
   information to knowledge gathered from the TCP timestamp could
   become a valuable factor in detecting NATs. In the code we may
   set two flags from this value:
     'stime' - when the timestamp is unnaturally small (less than one year 
               since the epoch). This is behaviour was seen in old Firefox
               releases, when gmt_unix_time is set to seconds since boot.
     'time' - when the timestamp is far off the current value (delta
              is bigger than 5 years). Most often this means that gmt_unix_time
              field is set to a random value. This was seen in some
              SSL crawlers.

 * 28 random bytes - not very useful. We set a flag:
      'rand' - when the random value doesn't look random and
               a word 0x0000 or 0xffff was detected.

 * session_id - a client may choose to resume previous SSL session. Ignored.

 * cipher_suites - a list of supported encryption algorithms ('cipher_suites')

 * compression_methods - a list of supported compression methods. There
   is only one valid compression method available, so we set a flag:
       'compr' - if compression is enabled 

 * extensions - a list of SSL extensions. Second, after cipher_suites,
   major source of data. ('extensions')


It's worth noting that SSL extensions contain not only a list of
supported extensions but also optional payload for every extension.
Currently, we ignore the payload as the experiments shown that it
isn't an interesting source of data - we can squeeze the same
entropy by just looking at the ordering of SSL extensions.
